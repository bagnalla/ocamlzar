# Zar OCaml: formally verified sampling from discrete probability distributions.

See the related [paper](https://arxiv.org/abs/2211.06747) (to appear
in PLDI'23) and main [Zar Github
repository](https://github.com/bagnalla/zar).

## Why use Zar?

### Probabilistic Choice

A basic operation in randomized algorithms is *probabilistic choice*:
for some `p ∈ [0,1]`, execute action `a1` with probability `p` or
action `a2` with probability `1-p` (i.e., flip a biased coin to
determine the path of execution). A common method for performing
probabilistic choice is as follows:
```ocaml
if Random.float 1.0 < p then a1 else a2
```

where `p` is a float in the range `[0,1]` and `Random.float 1.0`
produces a random float in the range `[0,1)`. While good enough for
many applications, this approach is not always correct due to float
roundoff error. We can only expect `a1` to be executed with
probability `p + ϵ` for some small error term `ϵ`, which technically
invalidates any correctness guarantee of our overall system that
depends on the correctness of its probabilistic choices.

Zar provides an alternative that is formally proved (in Coq) to
execute `a1` with probability `p` (where `n` and `d` are integers such
that `p = n/d`):
```ocaml
open Zar
Coin.build n d;; (* Build and cache coin with bias p = n/d *)
if Coin.flip () (* Flip the coin *)
  then a1 else a2
```

### Uniform Sampling

Another common operation is to randomly draw from a finite collection
of values with equal (uniform) probability of each. An old trick for
drawing an integer uniformly from the range `[0, n)` is to generate a
random integer from `[0, RAND_MAX]` and take the modulus wrt. `n`:
```C
k = rand() // n # Assign k random value from [0,n)
```
but this method suffers from modulo bias when `n` is not a power of 2,
causing some values to occur with higher probability than others (see,
e.g., [this
article](https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/)
for more information on modulo bias). Zar provides a uniform sampler
that is guaranteed for any integer `0 < n` to generate samples from
the range `[0,n)` with probability `1/n` each:
```ocaml
open Zar
Die.build n (* Build and cache n-sided die *)
let k = Die.roll () (* Roll the die *)
```

Although the OCaml function `Random.int` is ostensibly free from
modulo bias, our implementation guarantees it by a *formal proof of
correctness* in Coq.

### Finite Distributions

The coin and die samplers are special cases of a more general
construction for finite probability distributions that we provide
here. Given a list of nonnegative integer weights `weights` such that
`0 < weightsᵢ` for some `i` (at least one of the weights is nonzero),
we can draw an integer `k` from the range `[0, |weights|)` with
probability `weightsₖ / ∑ⱼweightsⱼ` (the corresponding weight of `k`
normalized by the sum of all weights):
```ocaml
open Zar
Findist.build weights (* Build and cache findist sampler *)
let k = Findist.sample () (* Draw a sample *)
```

For example, `Findist.build [1; 3; 2]` builds a sampler that draws
integers from the set `{0, 1, 2}` with `Pr(0) = 1/6`, `Pr(1) = 1/2`,
and `Pr(2) = 1/3`.

## Trusted Computing Base

The samplers provided by Zar have been implemented and verified in Coq
and extracted to OCaml for execution. Validity of the correctness
proofs is thus dependent on the correctness of Coq's extraction
mechanism, the OCaml compiler and runtime, and a small amount of OCaml
shim code (viewable
[here](https://github.com/bagnalla/zar/blob/main/ocaml/zar/lib/core.ml)
and thoroughly tested with QCheck
[here](https://github.com/bagnalla/zar/blob/main/ocaml/zar/test/zar.ml)),

## Proofs of Correctness

The samplers are implemented as choice-fix (CF) trees (an intermediate
representation used in the [Zar](https://github.com/bagnalla/zar)
compiler) and compiled to [interaction
trees](https://github.com/DeepSpec/InteractionTrees) that implement
them via reduction to sequences of fair coin flips. See Section 3 of
the [paper](https://arxiv.org/abs/2211.06747) for details and the file
[ocamlzar.v](https://github.com/bagnalla/zar/blob/main/ocamlzar.v) for
their implementations and proofs of correctness.

Correctness is two-fold. For biased coin with bias `p`, we prove:

*
  [coin_itree_correct](https://github.com/bagnalla/zar/blob/main/ocamlzar.v#L34):
  the probability of producing `true` according to the formal
  probabilistic semantics of the constructed interaction tree is equal
  to `p`, and

*
  [coin_true_converges](https://github.com/bagnalla/zar/blob/main/ocamlzar.v#67):
  when the source of random bits is uniformly distributed, for any
  sequence of coin flips the proportion of `true` samples converges to
  `p` as the number of samples goes to +∞.

The equidistribution result is dependent on uniform distribution of
the Boolean values generated by OCaml's
[`Random.bool`](https://v2.ocaml.org/api/Random.html) function. See
[the paper](https://arxiv.org/abs/2211.06747) for a more detailed
explanation.

Similarly, Theorem
[die_itree_correct](https://github.com/bagnalla/zar/blob/main/ocamlzar.v#L83)
proves semantic correctness of the n-sided die, and Corollary
[die_eq_n_converges](https://github.com/bagnalla/zar/blob/main/ocamlzar.v#L115)
that for any `m < n` the proportion of samples equal to `m` converges
to `1 / n`.

Theorem
[findist_itree_correct](https://github.com/bagnalla/zar/blob/main/ocamlzar.v#L128)
proves semantic correctness of findist samplers, and Corollary
[findist_eq_n_converges](https://github.com/bagnalla/zar/blob/main/ocamlzar.v#L166)
that for any weight vector `weights` and integer `0 <= i < |weights|`,
the proportion of samples equal to `i` converges to `weightsᵢ /
∑ⱼweightsⱼ`.

## Usage

`Core.seed ()` initializes the PRNG (currently just calls
[Random.self_init](https://v2.ocaml.org/api/Random.html)).

### Biased Coin

`Coin.build num denom` builds and caches a coin with `Pr(True) =
num/denom` for nonnegative integer `num` and positive integer `denom`.

`Coin.flip ()` produces a single Boolean sample by flipping the cached
coin.

`Coin.flips n` produces `n` Boolean samples by flipping the cached
coin.

See [coin.mli](lib/coin.mli).

### N-sided Die

`Die.build n` builds and caches an n-sided die with `Pr(m) = 1/n` for
integer `m` where `0 <= m < n`.

`Die.roll ()` produces a single sample by rolling the cached die.

`Die.rolls n` produces `n` samples by rolling the cached die.

See [die.mli](lib/die.mli).

### Finite Distribution

`Findist.build weights` builds and caches a sampler from list of
nonnegative integer weights `weights` (where `0 < weightsᵢ` for some
`i`) with `Pr(i) = weightsᵢ / ∑ⱼweightsⱼ` for integer `0 <= i <
|weights|`.

`Findist.sample ()` produces a single sample from the cached sampler.

`Findist.samples n` produces n samples from the cached sampler.

See [findist.mli](lib/findist.mli).

## Performance and Limitations

The implementations here are optimized for sampling performance at the
expense of sampler build time. Thus, this library not be ideal if your
use case involves frequent changes in the samplers' parameters (e.g.,
the coin bias or the number of sides of the die). For example, in our
experiments it takes ~0.22s to build a 100000-sided die and 1.83s to
build a 500000-sided die, but only ~1.85s and ~2.19s respectively to
generate one million samples from them.

The size of the in-memory representation of a coin with bias `p = num
/ denom` is proportional to `denom` (after bringing the fraction to
reduced form). The size of an `n`-sided die is proportional to `n`,
and the size of a finite distribution to the sum of its weights. The
formal results we provide are partial in the sense that they only
apply to samplers that execute without running out of memory. I.e., we
do not provide any guarantees against stack overflow or out-of-memory
errors when, e.g., `n` is too large.
